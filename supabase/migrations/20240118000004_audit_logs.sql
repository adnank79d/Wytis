-- Migration: 20240118000004_audit_logs
-- Description: Creates audit_logs table and automation triggers.

--------------------------------------------------------------------------------
-- 1. CREATE TABLE
--------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.audit_logs (
  id uuid NOT NULL PRIMARY KEY DEFAULT gen_random_uuid(),
  business_id uuid REFERENCES public.businesses(id) ON DELETE CASCADE,
  user_id uuid REFERENCES public.users(id) ON DELETE SET NULL, -- Keep log even if user deleted
  action text NOT NULL,
  details jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now()
);

--------------------------------------------------------------------------------
-- 2. ENABLE RLS
--------------------------------------------------------------------------------
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Policy: Owners can view logs for their business
CREATE POLICY "Owners can view audit logs"
ON public.audit_logs
FOR SELECT
TO authenticated
USING (
  EXISTS (
    SELECT 1 FROM public.memberships m
    WHERE m.business_id = audit_logs.business_id
    AND m.user_id = auth.uid()
    AND m.role = 'owner'
  )
);

-- Policy: System/Triggers can insert (Implicit via Security Definer usually, but for client insertion:)
-- We restrict client insertion to prevent tampering. Logs should be generated by Triggers/API.
-- But if we want API to log, we need INSERT policy.
-- Let's rely on Triggers and Security Definer functions for integrity.
-- So NO insert policy for public/authenticated users directly on this table if possible.
-- EXCEPT: The API uses the authenticated user's client.
-- If the API tries to insert, it needs permission.
-- Let's allow users to insert logs for their OWN business if we do client-side logging?
-- No, prompt says "Backend enforcement".
-- Safest: Only allowing INSERTs via Triggers (Security Definer).

--------------------------------------------------------------------------------
-- 3. TRIGGERS FOR AUTOMATION
--------------------------------------------------------------------------------

-- Function to log invoice events
CREATE OR REPLACE FUNCTION public.log_invoice_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF (TG_OP = 'INSERT') THEN
    INSERT INTO public.audit_logs (business_id, user_id, action, details)
    VALUES (NEW.business_id, auth.uid(), 'invoice_created', jsonb_build_object('invoice_id', NEW.id, 'number', NEW.invoice_number));
  ELSIF (TG_OP = 'UPDATE' AND OLD.status != 'issued' AND NEW.status = 'issued') THEN
    INSERT INTO public.audit_logs (business_id, user_id, action, details)
    VALUES (NEW.business_id, auth.uid(), 'invoice_issued', jsonb_build_object('invoice_id', NEW.id, 'number', NEW.invoice_number, 'amount', NEW.total_amount));
  END IF;
  RETURN NULL;
END;
$$;

CREATE TRIGGER on_invoice_audit
AFTER INSERT OR UPDATE ON public.invoices
FOR EACH ROW
EXECUTE FUNCTION public.log_invoice_changes();

-- Function to log membership changes (Role changes)
CREATE OR REPLACE FUNCTION public.log_membership_changes()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
BEGIN
  IF (TG_OP = 'UPDATE' AND OLD.role != NEW.role) THEN
    INSERT INTO public.audit_logs (business_id, user_id, action, details)
    VALUES (NEW.business_id, auth.uid(), 'role_changed', jsonb_build_object('target_user_id', NEW.user_id, 'old_role', OLD.role, 'new_role', NEW.role));
  END IF;
  RETURN NULL;
END;
$$;

CREATE TRIGGER on_membership_audit
AFTER UPDATE ON public.memberships
FOR EACH ROW
EXECUTE FUNCTION public.log_membership_changes();
